import os
import json
import zipfile
from datetime import datetime
from typing import List, Dict, Any

class SkillEngine:
    """
    Project Epsilon: Cognitive Operational Excellence Hub
    Goal: Optimizing organizational throughput via real-time realization crystallization.
    Features: Automated skill detection and .skill file generation.
    """
    def __init__(self, skill_dir: str = "layers/layer_2_core"):
        self.skill_dir = skill_dir
        os.makedirs(self.skill_dir, exist_ok=True)

    def execute_automated_export(self, ledger_path: str = "layers/layer_1_domain/comprehensive_realization_dataset.json"):
        """
        Phase 7: Automated Skill Export.
        Loads realizations from the ledger and generates .skill files for high-Q items.
        """
        print(f"ðŸ› ï¸ Executing Automated Skill Export from {ledger_path}...")
        if not os.path.exists(ledger_path):
            print("âš ï¸ Ledger not found. Skipping export.")
            return []

        with open(ledger_path, "r") as f:
            data = json.load(f)

        realizations_data = data.get("realizations", [])

        # Convert dict to simple object for internal logic if needed,
        # but here we'll just use the dicts
        high_q_items = []
        for r in realizations_data:
            q = r.get("q_score", 0)
            layer = r.get("layer", -1)
            if q > 1.20 or (layer == 0 and q > 1.10):
                high_q_items.append(r)

        generated = []
        for item in high_q_items:
            name = self._sanitize_name(item["content"])
            if self._generate_skill_package(name, item):
                generated.append(name)

        print(f"âœ… Export Complete. Generated {len(generated)} new skill packages.")
        return generated

    def _sanitize_name(self, content: str) -> str:
        # Extract a name-like string from content
        clean = content.split(":")[1].strip() if ":" in content else content
        clean = clean.replace(" ", "-").lower()[:30]
        return "".join(c for c in clean if c.isalnum() or c == "-").strip("-")

    def _generate_skill_package(self, name: str, realization: Dict) -> bool:
        path = os.path.join(self.skill_dir, f"{name}.skill")
        if os.path.exists(path):
            return False

        print(f"ðŸ“¦ Generating Skill Package: {name}")

        # Temporary directory for packaging
        tmp_dir = f"tmp_skill_{name}"
        os.makedirs(tmp_dir, exist_ok=True)
        os.makedirs(os.path.join(tmp_dir, "scripts"), exist_ok=True)
        os.makedirs(os.path.join(tmp_dir, "references"), exist_ok=True)
        os.makedirs(os.path.join(tmp_dir, "templates"), exist_ok=True)

        # 1. SKILL.md
        md_content = f"""---
name: {name}
description: "Crystallized skill from realization: {realization['content']}"
q_score: {realization['q_score']:.4f}
---

# {name.replace('-', ' ').title()}

This skill was autonomously generated by Project Epsilon.

## Realization Context
- **Content**: {realization['content']}
- **Layer**: {realization['layer']}
- **Timestamp**: {realization.get('metadata', {}).get('timestamp', datetime.now().isoformat())}

## Usage
Automatically invoked when system identifies patterns matching {name}.
"""
        with open(os.path.join(tmp_dir, "SKILL.md"), "w") as f:
            f.write(md_content)

        # 2. scripts/example.py
        py_content = f"""# Autogenerated implementation for {name}
def execute():
    print("Executing {name} implementation...")
    # Based on Q={realization['q_score']}
    return True
"""
        with open(os.path.join(tmp_dir, "scripts/example.py"), "w") as f:
            f.write(py_content)

        # Create ZIP
        with zipfile.ZipFile(path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(tmp_dir):
                for file in files:
                    zipf.write(os.path.join(root, file),
                               os.path.relpath(os.path.join(root, file), tmp_dir))

        # Cleanup
        import shutil
        shutil.rmtree(tmp_dir)
        return True

if __name__ == "__main__":
    engine = SkillEngine()
    engine.execute_automated_export()
